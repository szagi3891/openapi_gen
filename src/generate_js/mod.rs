use std::collections::VecDeque;

use crate::generate_js::fix_to_camel_case::fix_to_camel_case;
use crate::open_api_spec::{OpenApiMethod, ParamIn, SpecHandlerType};
use crate::utils::ErrorProcess;

mod generate_ident;
mod generate_params_type;
mod generate_response_io;
mod fix_to_camel_case;

fn add_import_query_string(spec: &SpecHandlerType) -> &str {
    for param in spec.parameters.iter() {
        if param.where_in == ParamIn::Query {
            return "import qs from 'query-string';";
        }
    }

    return "";
}

pub fn generate_js(name_in_file: String, url: String, method: OpenApiMethod, handler: &SpecHandlerType) -> Result<String, ErrorProcess> {
    let left = '{';
    let right = '}';

    let import_query_string = add_import_query_string(handler);
    let generate_params_type = generate_params_type::generate_params_type(handler);
    let generate_response_io_data = generate_response_io::generate_response_io(handler, &url, &method);
    let generate_url = generate_url(url, handler);
    let generate_method = get_method(&method);
    let generate_body = get_body(handler);

    let content = format!(r#"//The contents of this file have been generated automatically. Do not edit this file.

import * as t from 'io-ts';
import {left} isRight {right} from 'fp-ts/lib/Either';
import {left} fetchGeneralRaw, FetchGeneralRawResponseType {right} from 'src_common/common/fetch';
import {left} ApiTimeLog {right} from 'src_common/server/webDriver/logFormat';
{import_query_string}


{generate_params_type}


{generate_response_io_data}


export const {name_in_file} = async (api_url: string, api_timeout: number, backendToken: string, params: ParamsType): Promise<FetchGeneralRawResponseType> => {left}
    const url = `${left}api_url{right}{generate_url}`;
    const method = {generate_method};
    const paramsFetch = {left}
        url,
        body: {generate_body},
        backendToken,
        timeout: api_timeout,
    {right};

    const apiTime = ApiTimeLog.createWithProcessEnv(method, url);
    const response = await fetchGeneralRaw(method, paramsFetch);
    apiTime.show(response.status);
    return response;
{right};
"#);

    Ok(content)
}

fn get_method(method: &OpenApiMethod) -> String {
    let method = method.to_upper_case();
    format!("'{method}'")
}

fn generate_url(url: String, spec: &SpecHandlerType) -> String {
    /*
        convert url:
        /website-cms/{universe}/landing/landing_promo_page
        /website-cms/${params.universe}/landing/landing_promo_page
    */

    let base_url = url.split('/').map(generate_url_item).collect::<Vec<String>>().join("/");

    let mut query_params = Vec::<&String>::new();

    for param in spec.parameters.iter() {
        if param.where_in == ParamIn::Query {
            query_params.push(&param.name);
        }
    }

    if query_params.len() > 0 {
        let query = generate_url_query(query_params);
        return format!("{base_url}?{query}");

    } else {
        return base_url;
    }
}

fn generate_url_query(query_params: Vec<&String>) -> String {
    let left = '{';
    let right = '}';

    let mut param_chunks = Vec::<String>::new();

    for param_name in query_params {
        let param_name_camel_case = fix_to_camel_case(&param_name);
        param_chunks.push(format!("'{param_name}': params.{param_name_camel_case}"));
    }

    let param_result = param_chunks.join(", ");

    format!("${left}qs.stringify({left} {param_result} {right}, {left} skipNull: true {right}){right}")
}

fn generate_url_item(url_chunk: &str) -> String {
    /*
    convert chunk:
    {universe}
    ${params.universe}
    */

    let left = '{';
    let right = '}';

    let mut chars = url_chunk.chars().collect::<VecDeque<_>>();

    let first = chars.pop_front();
    let last = chars.pop_back();

    if first == Some('{') && last == Some('}') {
        let inner: String = chars.iter().collect();
        let inner = fix_to_camel_case(&inner);

        return format!("${left}params.{inner}{right}");
    }

    return url_chunk.to_string();
}

fn get_body(spec: &SpecHandlerType) -> String {
    for param in spec.parameters.iter() {
        if param.where_in == ParamIn::Body {
            let name = &param.name;
            return format!("params.{name}");
        }
    }

    "undefined".into()
}

